<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>HuddleBoard Display</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="health-monitor/health-monitor.css">
</head>

<body>
    <div id="app"></div>

    <!-- Configuration -->
    <script src="../config.js"></script>

    <!-- Modules HuddleBoard -->
    <script src="health-monitor/health-monitor.js"></script>
    <script src="js/scale-handler.js"></script>
    <script src="js/refresh-service.js"></script>
    <script src="js/display-manager.js"></script>

    <!-- Application principale -->
    <script>
        /**
         * Centralized Error Reporting Utility
         */
        class ErrorReporter {
            constructor(healthMonitor = null) {
                this.healthMonitor = healthMonitor || window.healthMonitor;
            }

            report(error, context = {}) {
                const errorData = this.formatError(error, context);
                
                if (this.tryHealthMonitorReport(errorData)) return;
                this.fallbackReport(errorData);
            }

            reportWarning(message, context = {}) {
                this.report(new Error(message), { ...context, severity: 'warning' });
            }

            reportInfo(message, context = {}) {
                this.report(new Error(message), { ...context, severity: 'info' });
            }

            formatError(error, context) {
                return {
                    type: context.type || 'unknown',
                    message: error?.message || String(error) || 'Unknown error',
                    source: context.source || 'Unknown',
                    severity: context.severity || 'error',
                    timestamp: Date.now(),
                    stack: error?.stack,
                    metadata: context.metadata || {}
                };
            }

            tryHealthMonitorReport(errorData) {
                if (!this.healthMonitor?.recordError) return false;
                
                try {
                    this.healthMonitor.recordError(errorData);
                    return true;
                } catch (e) {
                    console.warn('Health monitor error reporting failed:', e);
                    return false;
                }
            }

            fallbackReport(errorData) {
                const logMethod = this.getLogMethod(errorData.severity);
                logMethod(`[${errorData.source}] ${errorData.message}`, errorData);
            }

            getLogMethod(severity) {
                switch (severity) {
                    case 'warning': return console.warn.bind(console);
                    case 'info': return console.info.bind(console);
                    default: return console.error.bind(console);
                }
            }

            createSourceReporter(source) {
                return {
                    report: (error, context = {}) => this.report(error, { ...context, source }),
                    reportWarning: (message, context = {}) => this.reportWarning(message, { ...context, source }),
                    reportInfo: (message, context = {}) => this.reportInfo(message, { ...context, source })
                };
            }
        }

        /**
         * Event Management Utility
         */
        class EventManager {
            constructor() {
                this.listeners = new Map();
            }

            add(element, event, handler, options = {}) {
                const key = this.createKey(element, event, handler);
                element.addEventListener(event, handler, options);
                this.listeners.set(key, { element, event, handler, options });
            }

            remove(element, event, handler) {
                const key = this.createKey(element, event, handler);
                const listener = this.listeners.get(key);
                if (listener) {
                    element.removeEventListener(event, handler);
                    this.listeners.delete(key);
                }
            }

            removeAll() {
                for (const [key, listener] of this.listeners) {
                    listener.element.removeEventListener(listener.event, listener.handler);
                }
                this.listeners.clear();
            }

            createKey(element, event, handler) {
                return `${element.tagName || 'unknown'}_${event}_${handler.name || 'anonymous'}`;
            }
        }

        /**
         * Unified Banner Management System
         */
        class BannerManager {
            constructor() {
                this.activeBanners = new Map();
                this.elementCache = new Map();
                this.templates = {
                    status: { 
                        class: 'status-banner bottom-left',
                        template: (data) => `
                            <div class="status-indicator ${data.statusClass}"></div>
                            <div class="status-text">
                                <div class="status-primary">${data.statusText}</div>
                                <div class="status-secondary">${data.secondaryText}</div>
                            </div>
                        `
                    },
                    modif: {
                        class: 'modif-banner bottom-right',
                        template: (data) => `
                            <svg class="modif-icon" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
                            </svg>
                            <div class="modif-text">
                                <div class="modif-primary">Synchronis√©</div>
                                <div class="modif-time">${data.timeAgo}</div>
                            </div>
                        `
                    },
                    loading: {
                        class: 'loading-banner bottom-right',
                        template: (data) => `
                            <div class="loading-spinner"></div>
                            <span>${data.message}</span>
                        `
                    },
                    error: {
                        class: 'error-banner bottom-right',
                        template: (data) => `
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                            </svg>
                            <span>${data.message}</span>
                        `
                    },
                    warning: {
                        class: 'warning-banner bottom-right',
                        template: (data) => `
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                            </svg>
                            <span>${data.message}</span>
                        `
                    }
                };
            }

            show(type, data, options = {}) {
                const template = this.templates[type];
                if (!template) {
                    console.warn(`Unknown banner type: ${type}`);
                    return null;
                }

                const bannerId = options.id || `${type}-banner`;
                const element = this.getOrCreateElement(bannerId, template.class);
                element.innerHTML = template.template(data);

                this.activeBanners.set(bannerId, {
                    element,
                    type,
                    timer: options.duration > 0 ? 
                        setTimeout(() => this.hide(bannerId), options.duration) : null
                });

                return element;
            }

            hide(bannerId) {
                const banner = this.activeBanners.get(bannerId);
                if (banner) {
                    if (banner.timer) clearTimeout(banner.timer);
                    banner.element.remove();
                    this.activeBanners.delete(bannerId);
                    this.elementCache.delete(bannerId);
                }
            }

            update(bannerId, data) {
                const banner = this.activeBanners.get(bannerId);
                if (banner) {
                    const template = this.templates[banner.type];
                    banner.element.innerHTML = template.template(data);
                }
            }

            getOrCreateElement(id, className) {
                let element = this.elementCache.get(id);
                if (!element || !document.body.contains(element)) {
                    element = document.createElement('div');
                    element.id = id;
                    element.className = `banner ${className}`;
                    document.body.appendChild(element);
                    this.elementCache.set(id, element);
                }
                return element;
            }

            cleanup() {
                for (const [bannerId, banner] of this.activeBanners) {
                    if (banner.timer) clearTimeout(banner.timer);
                    banner.element.remove();
                }
                this.activeBanners.clear();
                this.elementCache.clear();
            }
        }

        /**
         * Time Formatting Utility - FIXED: Removed TypeScript 'readonly' keyword
         */
        class TimeFormatter {
            // ‚úÖ FIXED: Using standard JavaScript static properties
            static MILLISECONDS_PER_MINUTE = 60000;
            static MINUTES_PER_HOUR = 60;
            static HOURS_PER_DAY = 24;

            static formatTimeAgo(date) {
                const now = new Date();
                const diffMs = now.getTime() - date.getTime();
                const diffMinutes = Math.floor(diffMs / this.MILLISECONDS_PER_MINUTE);

                if (diffMinutes < 1) return '√† l\'instant';
                if (diffMinutes < this.MINUTES_PER_HOUR) {
                    return `il y a ${diffMinutes}min`;
                }

                const diffHours = Math.floor(diffMinutes / this.MINUTES_PER_HOUR);
                if (diffHours < this.HOURS_PER_DAY) {
                    return `il y a ${diffHours}h`;
                }

                const diffDays = Math.floor(diffHours / this.HOURS_PER_DAY);
                return `il y a ${diffDays}j`;
            }

            static formatTime(date) {
                return date ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '‚Äî';
            }
        }

        /**
         * Core Application - Refactored with utilities
         */
        class Core {
            constructor() {
                this.display = null;
                this.displayManager = null;
                this.errorReporter = new ErrorReporter();
                this.bannerManager = new BannerManager();
                this.modifBannerTimer = null;
            }

            init() {
                console.log('üöÄ Initialisation HuddleBoard Display');

                try {
                    if (!this.validateConfig()) {
                        this.showConfigError();
                        return;
                    }

                    if (!this.loadDisplay()) {
                        this.showDisplayError();
                        return;
                    }

                    this.initDisplayManager();
                    console.log('‚úÖ HuddleBoard Display initialis√© avec succ√®s');
                } catch (error) {
                    this.errorReporter.report(error, {
                        type: 'core_init_error',
                        source: 'Core'
                    });
                    this.showConfigError();
                }
            }

            validateConfig() {
                // ‚úÖ FIXED: Use the ConfigValidator from config.js instead of declaring a new one
                if (typeof ConfigValidator === 'undefined') {
                    console.error('ConfigValidator not available from config.js');
                    return false;
                }

                const validation = ConfigValidator.validate(window.AppConfig);
                if (!validation.isValid) {
                    this.errorReporter.report(new Error('Configuration validation failed'), {
                        type: 'config_validation_error',
                        source: 'Core',
                        metadata: { errors: validation.errors }
                    });
                    return false;
                }
                return true;
            }

            loadDisplay() {
                const hash = window.location.hash;
                const slug = hash?.startsWith('#/') ? hash.substring(2) : null;

                if (!slug) {
                    this.errorReporter.reportWarning('Missing slug in URL', {
                        type: 'missing_slug',
                        source: 'Core'
                    });
                    return false;
                }

                this.display = window.AppConfig.displays.find(d => d?.slug === slug);

                if (!this.display) {
                    this.errorReporter.reportWarning(`Display '${slug}' not found`, {
                        type: 'display_not_found',
                        source: 'Core',
                        metadata: { slug }
                    });
                    return false;
                }

                console.log(`üì∫ Display charg√©: ${this.display.name} (${this.display.slug})`);
                return true;
            }

            initDisplayManager() {
                this.displayManager = new DisplayManager(this.display, this.errorReporter);
                this.displayManager.render();
            }

            showConfigError() {
                document.getElementById('app').innerHTML = `
                    <div style="padding: 50px; text-align: center; font-family: Arial; color: #dc2626;">
                        <h2>‚ùå Configuration manquante</h2>
                        <p>Le fichier config.js est manquant ou invalide</p>
                        <a href="../" style="color: #dc2626; text-decoration: none;">‚Üê Retour √† l'accueil</a>
                    </div>
                `;
            }

            showDisplayError() {
                const hash = window.location.hash?.substring(2) || 'unknown';
                document.getElementById('app').innerHTML = `
                    <div style="padding: 50px; text-align: center; font-family: Arial; color: #dc2626;">
                        <h2>‚ùå Display non trouv√©</h2>
                        <p>Le display '${hash}' n'existe pas dans la configuration</p>
                        <a href="../" style="color: #dc2626; text-decoration: none;">‚Üê Retour √† l'accueil</a>
                    </div>
                `;
            }

            // Unified banner methods using BannerManager
            showModifBanner(date = new Date()) {
                try {
                    localStorage.setItem('hb_sync', date.getTime());
                } catch (e) {
                    console.warn('Impossible de sauvegarder la date de sync:', e);
                }

                if (this.modifBannerTimer) {
                    clearInterval(this.modifBannerTimer);
                }

                const updateTime = () => {
                    try {
                        const lastSync = localStorage.getItem('hb_sync');
                        const syncDate = lastSync ? new Date(parseInt(lastSync)) : date;
                        const timeAgo = TimeFormatter.formatTimeAgo(syncDate);

                        this.bannerManager.update('modif-banner', { timeAgo });
                    } catch (e) {
                        console.warn('Erreur lors de la mise √† jour du banner:', e);
                    }
                };

                const timeAgo = TimeFormatter.formatTimeAgo(date);
                this.bannerManager.show('modif', { timeAgo }, { id: 'modif-banner' });
                
                updateTime();
                this.modifBannerTimer = setInterval(updateTime, 60000);
            }

            showStatusBanner(date, ok = true, errorCount = 0) {
                this.showStatusBanner.lastDate = ok && date ? date : this.showStatusBanner.lastDate;

                let statusClass, statusText, secondaryText;

                if (!ok) {
                    statusClass = 'status-fail';
                    statusText = 'Hors ligne';
                    secondaryText = 'Reconnexion...';
                } else if (errorCount > 5) {
                    statusClass = 'status-warning';
                    statusText = 'Instable';
                    secondaryText = `${errorCount} erreurs`;
                } else {
                    statusClass = 'status-online';
                    statusText = 'En ligne';
                    secondaryText = TimeFormatter.formatTime(this.showStatusBanner.lastDate);
                }

                this.bannerManager.show('status', {
                    statusClass,
                    statusText,
                    secondaryText
                }, { id: 'status-banner' });
            }

            showLoadingBanner(message = 'Chargement...') {
                this.bannerManager.show('loading', { message }, { id: 'loading-banner' });
            }

            showErrorBanner(message, duration = 5000) {
                this.bannerManager.show('error', { message }, { 
                    id: 'error-banner',
                    duration 
                });
            }

            showWarningBanner(message, duration = 5000) {
                this.bannerManager.show('warning', { message }, { 
                    id: 'warning-banner',
                    duration 
                });
            }

            hideLoadingBanner() {
                this.bannerManager.hide('loading-banner');
            }

            cleanup() {
                console.log('üßπ Nettoyage Core Application');

                if (this.modifBannerTimer) {
                    clearInterval(this.modifBannerTimer);
                    this.modifBannerTimer = null;
                }

                this.bannerManager.cleanup();

                if (this.displayManager) {
                    this.displayManager.cleanup();
                    this.displayManager = null;
                }

                this.display = null;
            }

            async getAppInfo() {
                return {
                    display: this.display ? {
                        name: this.display.name,
                        slug: this.display.slug,
                        path: this.display.path
                    } : null,
                    displayManager: this.displayManager ? this.displayManager.getDisplayInfo() : null,
                    lastSync: this.getLastSyncInfo()
                };
            }

            getLastSyncInfo() {
                try {
                    const lastSync = localStorage.getItem('hb_sync');
                    if (lastSync) {
                        const date = new Date(parseInt(lastSync));
                        return {
                            timestamp: parseInt(lastSync),
                            date: date.toLocaleString(),
                            timeAgo: TimeFormatter.formatTimeAgo(date)
                        };
                    }
                } catch (e) {
                    console.warn('Erreur lors de la lecture de la derni√®re sync:', e);
                }
                return null;
            }
        }

        // Global instances
        const app = new Core();
        const globalErrorReporter = new ErrorReporter();

        // Make utilities globally available for backward compatibility
        window.showModifBanner = (date) => app.showModifBanner(date);
        window.showStatusBanner = (date, ok, errorCount) => app.showStatusBanner(date, ok, errorCount);
        window.showLoadingBanner = (message) => app.showLoadingBanner(message);
        window.showErrorBanner = (message, duration) => app.showErrorBanner(message, duration);
        window.showWarningBanner = (message, duration) => app.showWarningBanner(message, duration);
        window.hideLoadingBanner = () => app.hideLoadingBanner();
        window.cleanupBanners = () => app.bannerManager.cleanup();
        window.ErrorReporter = ErrorReporter;
        window.TimeFormatter = TimeFormatter;

        // Event handlers
        window.addEventListener('beforeunload', () => app.cleanup());
        window.addEventListener('hashchange', () => {
            console.log('üîÑ Changement de hash d√©tect√©, rechargement...');
            app.cleanup();
            setTimeout(() => app.init(), 100);
        });

        // Initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => app.init());
        } else {
            app.init();
        }

        // Expose for debugging
        window.HuddleBoardApp = app;
        window.debug = {
            getAppInfo: () => app.getAppInfo(),
            forceRefresh: () => app.displayManager?.forceRefresh(),
            getScaleInfo: () => app.displayManager?.scaleHandler?.getScaleInfo(),
            getRefreshStats: () => app.displayManager?.refreshService?.getStats(),
            setFillMode: (mode) => app.displayManager?.scaleHandler?.setFillMode(mode),
        };

        console.log('üõ†Ô∏è Commandes debug disponibles: window.debug');
    </script>
</body>

</html>